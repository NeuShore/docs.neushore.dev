"use strict";(self.webpackChunkbrayanbot_dev=self.webpackChunkbrayanbot_dev||[]).push([[1477],{10:function(e){e.exports=JSON.parse('{"blogPosts":[{"id":"windows-gui-installation","metadata":{"permalink":"/blog/windows-gui-installation","editUrl":"https://github.com/brayanbotdev/brayanbot/edit/dev/blog/2022-04-02-windows-gui.md","source":"@site/blog/2022-04-02-windows-gui.md","title":"Windows GUI Installation","description":"Install BrayanBot on a remote server using Putty and WinSCP.","date":"2022-04-02T00:00:00.000Z","formattedDate":"April 2, 2022","tags":[{"label":"Windows","permalink":"/blog/tags/windows"},{"label":"Linux","permalink":"/blog/tags/linux"},{"label":"Ubuntu","permalink":"/blog/tags/ubuntu"}],"readingTime":0.17,"truncated":true,"authors":[{"name":"NotAShelf (raf)","title":"BrayanBot Developer & Lead Wiki Maintainer","url":"https://github.com/NotAShelf","image_url":"https://notashelf.dev/_next/image/?url=https%3A%2F%2Fmedia.discordapp.net%2Fattachments%2F815616931788357652%2F818941172591624192%2Fraf.jpg&w=256&q=75","imageURL":"https://notashelf.dev/_next/image/?url=https%3A%2F%2Fmedia.discordapp.net%2Fattachments%2F815616931788357652%2F818941172591624192%2Fraf.jpg&w=256&q=75"}],"frontMatter":{"title":"Windows GUI Installation","description":"Install BrayanBot on a remote server using Putty and WinSCP.","slug":"windows-gui-installation","authors":[{"name":"NotAShelf (raf)","title":"BrayanBot Developer & Lead Wiki Maintainer","url":"https://github.com/NotAShelf","image_url":"https://notashelf.dev/_next/image/?url=https%3A%2F%2Fmedia.discordapp.net%2Fattachments%2F815616931788357652%2F818941172591624192%2Fraf.jpg&w=256&q=75","imageURL":"https://notashelf.dev/_next/image/?url=https%3A%2F%2Fmedia.discordapp.net%2Fattachments%2F815616931788357652%2F818941172591624192%2Fraf.jpg&w=256&q=75"}],"tags":["Windows","Linux","Ubuntu"],"hide_table_of_contents":false},"nextItem":{"title":"Hardening your Linux Server","permalink":"/blog/hardening-linux-server"}},"content":"This page is currently a placeholder as I do not have access to a Windows machine. Will be updated soon, thank you for your patience!\\n\\nFor installation support, consider joining our [Discord Server](/discord).\\n\\n\x3c!--truncate--\x3e"},{"id":"hardening-linux-server","metadata":{"permalink":"/blog/hardening-linux-server","editUrl":"https://github.com/brayanbotdev/brayanbot/edit/dev/blog/2022-02-17-securing-linux.md","source":"@site/blog/2022-02-17-securing-linux.md","title":"Hardening your Linux Server","description":"Because all have to secure our penguins.","date":"2022-02-17T00:00:00.000Z","formattedDate":"February 17, 2022","tags":[{"label":"Linux","permalink":"/blog/tags/linux"},{"label":"Ubuntu","permalink":"/blog/tags/ubuntu"},{"label":"Security","permalink":"/blog/tags/security"}],"readingTime":16.92,"truncated":true,"authors":[{"name":"NotAShelf (raf)","title":"BrayanBot Developer & Lead Wiki Maintainer","url":"https://github.com/NotAShelf","image_url":"https://notashelf.dev/_next/image/?url=https%3A%2F%2Fmedia.discordapp.net%2Fattachments%2F815616931788357652%2F818941172591624192%2Fraf.jpg&w=256&q=75","imageURL":"https://notashelf.dev/_next/image/?url=https%3A%2F%2Fmedia.discordapp.net%2Fattachments%2F815616931788357652%2F818941172591624192%2Fraf.jpg&w=256&q=75"}],"frontMatter":{"title":"Hardening your Linux Server","description":"Because all have to secure our penguins.","slug":"hardening-linux-server","authors":[{"name":"NotAShelf (raf)","title":"BrayanBot Developer & Lead Wiki Maintainer","url":"https://github.com/NotAShelf","image_url":"https://notashelf.dev/_next/image/?url=https%3A%2F%2Fmedia.discordapp.net%2Fattachments%2F815616931788357652%2F818941172591624192%2Fraf.jpg&w=256&q=75","imageURL":"https://notashelf.dev/_next/image/?url=https%3A%2F%2Fmedia.discordapp.net%2Fattachments%2F815616931788357652%2F818941172591624192%2Fraf.jpg&w=256&q=75"}],"tags":["Linux","Ubuntu","Security"],"hide_table_of_contents":false},"prevItem":{"title":"Windows GUI Installation","permalink":"/blog/windows-gui-installation"},"nextItem":{"title":"Hosting BrayanBot on a Raspberry Pi 400","permalink":"/blog/raspberry-pi-installation"}},"content":"No server is 100% secure -and if you want an impenetrable server, you would need to unplug your machine and throw it into the trash bin- but we can at least do our best to make our server secure and a safe box for our data, which is why this guide exists. Ready? Great! Click \\"Read More\\" and... well, prepare to _read more_.\\n\\n\x3c!--truncate--\x3e\\n\\n## Preface\\n\\nIf you are running a server that is connected to the internet, there is a huge chance that you have chosen Linux as your server\'s operating system. And while Linux is, by default, a system more secure than Windows; it will be much more secure once you take the required actions and turn it into a fortress.\\n\\n> While this guide will cover primarly the steps for an **Ubuntu** server, the process is not too different for similar systems.\\n\\nThis guide will assume that you are on a **fresh (if not a not-yet-configured) installation** of Ubuntu and are running version 20.04 LTS. This guide may -and probably will- apply to newer (or with lesser chance of success, older) versions but it is prepared on a server running Ubuntu 20.04 LTS and I rarely feel the need to downgrade to older versions. 21.04 is one of the worst Ubuntu versions to day, and 22.04 (next LTS release) is well on the way. Until 22.04 is out, let us stick with 20.04 and do our absolute best to secure our server.\\n\\n### Requisites\\n\\n- Root Access\\n- A stable connection to the internet\\n- Packages like `nano` or `vim` installed\\n- Ubuntu 20.04\\n- A SSH client (on Windows) or a Terminal Emulator (on Linux)\\n- Common sense\\n\\n### Recommendations\\n\\nThose are pretty self-explanatory, and often times you follow those steps without realizing. But, it is always great to mention them.\\n\\n1. Update regularly or automatically.\\n\\n2. Install only the necessary packages.\\n\\n3. Enforce good password policies for your users.\\n\\n4. Do not give your password to untrusted third parties and if you do for a good reason, change the passwords afterwards.\\n\\n5. Do not allow access to your server from people you do not trust.\\n\\n6. Keep regular backups\\n\\n## Root Access\\n\\nOnce you purchase a VPS or a Dedicated Server, you will most likely be given access to the root user, who has full privileges. You may continue using root user, but you will need to keep in mind that running **every** application with root privileges (a result of using the root user) is unsafe and highly discouraged. Which is why, we will be creating our own non-root user with **sudo privileges**\\n\\n```bash\\nssh root@ip_address\\n```\\n\\n```bash\\nadduser username # replace username with your desired username\\n```\\n\\nYou will be prompted with a few questions for your details. You do not need to provide any of those, but some software (like git) use those details to easily pull your details without you having to configure it twice. Needless to say, it is up to you.\\n\\n```bash\\nsudo adduser dummy\\n\\nAdding user dummy ...\\nAdding new group dummy (1001) ...\\nAdding new user dummy (1001) with group dummy ...\\nCreating home directory /home/raf2 ...\\nCopying files from /etc/skel ...\\nNew password: # enter your password - not optional\\nRetype new password: # confirm your password - also not optional\\npasswd: password updated successfully\\nChanging the user information for dummy\\nEnter the new value, or press ENTER for the default\\n        Full Name []: # optional\\n        Room Number []: # optional\\n        Work Phone []: # optional\\n        Home Phone []: # optional\\n        Other []: # optional\\nIs the information correct? [Y/n]\\n```\\n\\nReview your information, and type `Y` to confirm user creation.<br/>And this will do it for user creation, however, we still need to assign sudo privileges to this user before we ditch **root** and switch to our newly created user.\\n\\n### Passwords\\n\\n> Passwords, without any doubt, are a part of our lives and no matter the platform; using a safe password is one of the easiest steps you can take to secure your server. Most hosting providers will generate a password that are _relatively_ secure but you must keep in mind that there is an algorithm behind the generation of those passwords and thus, they are prone to security vulnerabilities. Which means, you **must** create your own, more secure password. You can leave the root password as the default one, as we will be locking it later on, but it may still be a good idea to change it to something much more secure than the default.\\n\\nTo change your _own_ password, run\\n\\n```bash\\npasswd\\n```\\n\\nand enter your password, then confirm.\\n\\nTo change _another user\'s_ password, run\\n\\n```bash\\npasswd username\\n```\\n\\nand enter the new password, then confirm.\\n\\n### Password Policies\\n\\n> If you are a Sysadmin enforcing system-wide security within your server, you can enforce users to change their passwords periodically by setting them to expire. This is not necessary, and most users will likely negelct this step but if you choose to take the extra step; I will not judge and instead, will show you how.\\n\\nEnforcing a password expiry policy can be done by adding the `-e` or `--expire` flag while running the `passwd` command and forcing an user\'s password to expire (thus forcing them to change it) or automatically.\\n\\n1. Install `chage` package, it is included by default in some distributions but you may be missing it\\n\\n```bash\\nsudo apt-get install chage\\n```\\n\\n2. Use the `-M` flag to set the amount of days between password changes. E.g. setting it to 10 will require an user to change their password every 10 days.\\n\\n```bash\\nsudo chage -M 10 username\\n```\\n\\nThis will force an user to change their password every 10 days, but I recommend that you choose a more reasonable amount.\\n\\n3. To verify an user\'s expiry policy, run the `chage` command with the `-l` flag as follows:\\n\\n```bash\\nchage -l username\\n```\\n\\n#### Things to note\\n\\n- By default the number of days of warning before password expires is set to 7. The user will receive a warning about changing their password 7 days before the expiry date.\\n\\n- If the password expiry date reaches and user doesn\u2019t change their password, the system will force the user to change the password before the login\\n\\n- You may also lock an user\'s account permanently, with the option to be recovered by an administrator, if they haven\'t logged in for a predetermined amount of days after their password expires. To do so, run `change` with the `-I` flag as follows:\\n\\n```bash\\nchage -I 10 username\\n```\\n\\n### Limiting root privileges\\n\\nAs we have created our fresh user to use in the future, we need to assign sudo privileges to said user. `sudo` allows this user to run applications as **root** without exposing your root user to **exploits**. Use `sudo` only when necessary and avoid running applications with `sudo` if you have no idea where they are from or what they do.\\n\\nTo allow our new user to run commands with `sudo`, we need to add it to the **sudo group** by running the following command:\\n\\n```bash\\nusermod -aG sudo username # replace username with your own username\\n```\\n\\nAnd that is it! Now switch to your sudo user with `su - username`, once again replacing \\"username\\" with your username and test your sudo privileges with `sudo whoami`. If the response is **root**, then you are successful.\\n\\n![Sudo](../assets/sudo-1.png)\\n\\n## SSH\\n\\n### SSH Keys\\n\\n> SSH Keys are one of the most popular and effective systems to secure your server. And surprisingly easy too! Let\'s see how we can set up SSH Key Pairs in less than 5 steps.\\n\\n1. Generate your key pair by running the following command on your **own machine**\\n\\n```bash\\nssh-keygen -t rsa\\n```\\n\\n**Sample output:**\\n\\n```bash\\nGenerating public/private rsa key pair.\\nEnter file in which to save the key (/Users/raf/.ssh/id_rsa):\\nEnter passphrase (empty for no passphrase): # optional\\nEnter same passphrase again: # optional\\nYour identification has been saved in /Users/raf/.ssh/id_rsa.\\nYour public key has been saved in /Users/raf/.ssh/id_rsa.pub.\\n```\\n\\nThis command will generate your key pair with the names `id_rsa` and `id_rsa.pub` in the ssh directory\\n\\n- For Linux systems, this directory is located at `~/.ssh` or `/home/username/.ssh` (both are the same)\\n- For Windows system, this directory will be located at `C:\\\\Users\\\\username\\\\.ssh`\\n\\n2. Copy your public key (id_rsa.pub) to your **server**\\n\\n**Linux**\\n\\n```bash\\nssh-copy-id -i $HOME/.ssh/id_rsa.pub username@ip_address # replace username with your sudo user (not root) and ip_address with your server\'s IP address\\n```\\n\\n**Windows**\\n\\n```bash\\ntype $env:USERPROFILE\\\\.ssh\\\\id_rsa.pub | ssh username@ip_address \\"cat >> .ssh/authorized_keys\\" # replace username with your sudo user (not root) and ip_address with your server\'s IP address\\n```\\n\\n3. Test passwordless SSH connectivity\\n\\n```bash\\nssh -v username@ip_address # replace username with your sudo user (not root) and ip_address with your server\'s IP address\\n```\\n\\n### SSH Config\\n\\n> While not mandatory and not too significant for security, you can choose to configure your SSH connection. To do this, you will need to add an entry to the `config` file located in your SSH directory as follows:\\n\\n```yaml\\nHost server_name # desired hostname\\n   HostName ip_address # your server\'s IP address\\n   User username # username for the sudo user that you added SSH keys for\\n   Port 22 # your SSH port, 22 is the default one\\n   IdentityFile ~/.ssh/id_rsa # your private key\\n```\\n\\nNaturally, you need to edit those values to your liking but once you are done, you will be able to easily SSH into your server with\\n\\n```bash\\nssh server_name\\n```\\n\\n### Securing SSH\\n\\nThere are other things you can -and should- do to secure your SSH connection. Those things include:\\n\\n- Disable password authentication\\n- Change your SSH port (optional)\\n- Disable root login\\n\\nand can all be achieved from your SSHD config at `/etc/ssh/sshd_config`\\n\\n#### Disabling Password Authentication\\n\\nFind `#PasswordAuthentication yes` and replace `yes` with `no`.\\n\\n:::danger\\n\\nIt is very important that you do this _after_ setting up and testing your SSH keys. If you disable password authentication before you set up Pubkey authentication, you will lock yourself out of your server.\\n\\n:::\\n\\n#### Changing your SSH port\\n\\nFind `#Port 22`, uncomment it and replace 22 with your desired port number. Keep in mind that you will need to set your Firewall rules according to this setting, if you change it.\\n\\n#### Disable root login\\n\\nFind `PermitRootLogin` and set it as follows:\\n\\n```bash\\nPermitRootLogin no\\n```\\n\\nIf it is commented (if there is a \\"#\\" before it\'s name,) uncomment it (remove the \\"#\\".)\\n\\n## Firewall\\n\\nFirewall is a dangerous tool to play with, however, once you master it; you are able to fend your server from most attacks that target network exploits\\n\\n> While a lot of users neglect Firewall setup, I certainly recommend setting it up, however, if you are somewhat new to the whole Linux system and server administration, you may step this step. But make sure you follow other tips I have provided.\\n\\nThere are 2 common applications that I keep hearing about and personally use: `UFW` (Uncomplicated Firewall) and `iptables`.\\nWhile I do not recommend using a _specific_ one of those applications, you can easily choose the one that is for you based on the explanation below.\\n\\n### Comparison\\n\\n(Taken from [here](https://serverfault.com/questions/1014531/ufw-and-iptables-which-is-better-and-why))\\n\\n**I ain\'t afraid of no quake** I mean firewall! **[^1]**\\n\\n**TL;DR PART**\\n\\n> a simple image about pizza can answer sometimes many questions :)\\n>\\n> **Take a good look at this picture, then read the text below:**\\n>\\n> ![(IMAGE) Pizza as a Service \u2014 by Albert Barron](https://i.stack.imgur.com/qiEfi.png)\\n>\\n> We start from the left (blue means, you have to manage it, green means the vendor/software manages it)\\n>\\n> 1. Made at Home - **Netfilter** (Nightmare - Damn I\'m Good)\\n> 2. Take and Bake - **Iptables** (Hard - Come Get Some)\\n> 3. Delivery - **UFW** (Normal - Let\'s Rock)\\n> 4. Dining out - **Some 1-clicks or predefined setups** (Easy - Piece of Cake)\\n>\\n> UFW is something like a simplistic interface to get basic things done with your firewall.\\n>\\n> **How much you want to manage, depends solely on you :)**\\n\\n**THE LONGER PART**\\n\\n> **part I:** I found a pretty decent and easy to understand article for the UFW: [Understanding UFW](https://hackernoon.com/understanding-ufw-8d70d5d8f9d2)\\n>\\n> **part II:** This guide shows you the slight deeper using of iptables: [The Beginner\u2019s Guide to iptables, the Linux Firewall](https://www.howtogeek.com/177621/the-beginners-guide-to-iptables-the-linux-firewall/)\\n>\\n> **part III:** Here is information about the packetfilter, this is the basis of many firewall solutions [A Deep Dive into Iptables and\\n> [Netfilter Architecture](https://www.digitalocean.com/community/tutorials/a-deep-dive-into-iptables-and-netfilter-architecture)\\n>\\n> **The parts are based on hierarchy, top is dependant on the lower ones.**\\n\\n**[^1:]** (From Duke Nukem 3D - Referencing id Software\'s 1996 PC FPS game Quake)\\n\\n### UFW\\n\\nAs the U in UFW (\\"uncomplicated\\") indicates; UFW is supposed to be a simple solution for managing your firewall. And as such, I try to keep my UFW configuration as simple as possible.\\n\\n1. Install UFW\\n\\n```bash\\nsudo apt install ufw\\n```\\n\\n2. Check the status of your firewall\\n\\n```bash\\nsudo ufw status\\n```\\n\\n**It will say \\"inactive\\" if you have not yet configured it. If it says \\"active\\", turn it off until we need it enabled**\\n\\n3. Deny incoming packages and allow outgoing - don\'t worry, this will not cut off your SSH access as your firewall is currently **inactive**.\\n\\n```bash\\nsudo ufw default deny incoming\\nsudo ufw default allow outgoing\\n```\\n\\n4. Allow the SSH port\\n\\n```bash\\nsudo ufw allow 22 # If your SSH port is different, change it in this command.\\n```\\n\\n**or**\\n\\n```bash\\nsudo ufw allow ssh # this will grab the details from your SSH profile\\n```\\n\\nYou can also leave yourself a command while opening a port, like this\\n\\n```bash\\nsudo ufw allow 3000/tcp comment \'Open port for NextJS Application\'\\n```\\n\\n5. Allow other ports you want open\\n\\nI normally allow ports 80 and 443 for http and https access. Different services may require different ports.\\nYou can also allow port _ranges_ using a semicolon as follows:\\n\\n```bash\\nsudo ufw allow 3000:3100/tcp\\n```\\n\\nFor example this will allow TCP ports 3000 through 3100.\\n\\n6. Denying outgoing ports\\n\\nAs we disabled all incoming, you do not need to deny any additional ports. However, if you want to disable any _outgoing_ ports; you can deny it by running\\n\\n```bash\\nsudo ufw reject out port # replace port with the port you want to deny\\n```\\n\\n7. Limiting SSH port\\n\\nTo mitigate package attacks, you can choose to limit traffic on certain ports. By default, UFW limits 6 connections per 30 seconds with SSH connections in mind.\\n\\n```bash\\nsudo ufw limit ssh\\n```\\n\\n8. Enabling UFW\\n\\nIf you are satisfied with your UFW config, you are ready to enable UFW. But before, you might want to disable UFW from running on system boot by running\\n\\n```bash\\nsudo systemctl disable ufw\\n```\\n\\nand _only then_ enabling UFW\\n\\n```bash\\nsudo ufw enable # this will enable UFW\\n```\\n\\nIf all is good, re-enable UFW service by running\\n\\n```bash\\nsudo systemctl enable ufw\\n```\\n\\nIf you have managed to lock yourself out, reboot your server.\\n\\n9. Making Changes\\n\\nWhenever you make changes to your UFW configuration, you need to reload UFW\\n\\n```bash\\nsudo ufw reload\\n```\\n\\nTo view active UFW rules\\n\\n```bash\\nsudo ufw status numbered # this will display a numbered list\\n```\\n\\nTo delete an active UFW rule\\n\\n```bash\\nsudo ufw delete [number]\\n```\\n\\n### IPTABLES\\n\\n> Iptables is a relatively harder firewall to operate and as such, I treat it as one. While I can explain to you step by step, iptables unlike UFW has no intention to appear \\"uncomplicated\\" and explaining it would take far longer than this blog aims to be. Therefore, I will share my iptables setup with simple notes so that you can use it yourself, but I recommend sticking with UFW unless you _really_ know what you are doing.\\n\\n```bash\\nsudo iptables -A INPUT -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT\\n\\nsudo iptables -A OUTPUT -m conntrack --ctstate ESTABLISHED -j ACCEPT\\n\\nsudo iptables -A INPUT -p tcp -s  MY.IP.0.0/16 --dport 22 -m conntrack --ctstate NEW,ESTABLISHED -j ACCEPT # allow SSH port for input with subnet for last 2 digits\\n\\nsudo iptables -A OUTPUT -p tcp --sport 22 -m conntrack --ctstate ESTABLISHED -j ACCEPT # allow SSH port for output\\n\\nsudo iptables -A INPUT -p tcp --dport 80 -j ACCEPT # allow http port\\n\\nsudo iptables -A INPUT -p tcp --dport 443 -j ACCEPT # allow https port\\n\\nsudo iptables -A INPUT -i lo -j ACCEPT\\n\\nsudo iptables -A OUTPUT -o lo -j ACCEPT\\n\\nsudo iptables -P INPUT DROP # deny all incoming traffic\\n```\\n\\n> As I mentioned, it\'s a really bad idea to use this if you have no idea what you are doing and it _is_ pretty dangerous to copy and paste but this could be your guide once you feel accustomed to Linux, and most specifically; firewalls\\n\\n#### What does this do?\\n\\nThe commands you see above will quickly set up a firewall policy that denies all incoming traffic and allows all outgoing traffic. Then, it will allow SSH from my subnet[^2] and allow all outgoing SSH traffic. Then it will allow ports 80 and 443 to allow http and https access. Additional ports can be opened with\\n\\n```bash\\nsudo iptables -A INPUT -p tcp --dport 8080 -j ACCEPT # 8080 is the example, change it\\n```\\n\\nshould I need additional ports.\\n\\n[^2:] A subnet is basically a network inside a network. And the advantage is the most when you need to access your server from a range of IPs. Most internet service providers (ISPs) do not provide a static IP to their customers and while you _could_ ask them to, it\'s a known fact that ISPs do not provide _good_ services. Which is why we need to either make our IP static ourselves or allow an IP range to connect to our server, sacrificing _some_ security.\\n\\n### SaaS Firewalls\\n\\n> SaaS Firewalls refer to \\"Software as a Service\\" Firewalls, often provided by your server provider (through their website) or a third party (through an application.) Certainly, they are the most convenient and easiest way to configure a firewall but due to their primitiveness; I personally advise against using them. Choose UFW if you are a beginner and iptables or (not ideally) netfilter if you are an expert.\\n\\n### Additional notes\\n\\n- UFW uses iptables as its backend and is often preferred over iptables for home-servers\\n\\n- netfilter is also a choice when it comes to firewalls, but it sacrifices too much from convenience for the sake of security\\n\\n- iptables policies **will not** persist between reboots. If you want your iptables rules permanent, you will need to\\n\\n## Virus Scanning\\n\\n> Linux currently holds a smaller market share compared to Windows, and as such there are less viruses/malware targeting Linux systems. However, this does not mean that there are _no viruses_ targeting the Linux system. If you are dual booting Windows and Linux, or are using Linux on your server without an anti-virus; there is a chance that your system is infected. As such, you might want to install an anti-virus on your system.\\n\\nI personally use ClamAV and I find it to be working relatively well, but if you would like to use another AV or want to add one to this page; feel free.\\n\\n### Installing ClamAV\\n\\n1. Install ClamAV package\\n\\n```bash\\nsudo apt install clamav clamav-daemon -y\\n```\\n\\n2. Verify installation\\n\\n```bash\\nclamscan --V\\n```\\n\\n3. Enable clamav-freshclam service to automatically update virus database\\n\\n```bash\\nsudo systemctl status clamav-freshclam\\n```\\n\\n```bash\\nsudo systemctl start clamav-freshclam\\n```\\n\\n4. Download/Update Signature Database\\n\\nStop ClamAV service\\n\\n```bash\\nsudo systemctl stop clamav-freshclam\\n```\\n\\nUpdate Database\\n\\n```bash\\nsudo freshclam\\n```\\n\\nRestart ClamAV service\\n\\n```bash\\nsudo systemctl start clamav-freshclam\\n```\\n\\n5. Scanning for Viruses\\n\\n- Scan all files, starting from the current Directory\\n\\n```bash\\nclamscan -r /\\n```\\n\\n- Scan all files, but show only infected files\\n\\n```bash\\nclamscan -r -i /path/to/folder-you-want-to-scan\\n```\\n\\n- To scan infected files in a specific directory and then remove them\\n\\n```bash\\nclamscan --infected --remove --recursive /home/ubuntu/Desktop/\\n```\\n\\nAnd that is all!\\n\\n> For more information and commands, see [ClamAV man page](https://linux.die.net/man/1/clamscan) or run `clamscan -h`"},{"id":"raspberry-pi-installation","metadata":{"permalink":"/blog/raspberry-pi-installation","editUrl":"https://github.com/brayanbotdev/brayanbot/edit/dev/blog/2022-02-15-raspberry-pi.md","source":"@site/blog/2022-02-15-raspberry-pi.md","title":"Hosting BrayanBot on a Raspberry Pi 400","description":"Got a spare Pi to run BrayanBot on? This is the place!","date":"2022-02-15T00:00:00.000Z","formattedDate":"February 15, 2022","tags":[{"label":"Installation","permalink":"/blog/tags/installation"},{"label":"Raspberry Pi","permalink":"/blog/tags/raspberry-pi"},{"label":"Linux","permalink":"/blog/tags/linux"},{"label":"Ubuntu","permalink":"/blog/tags/ubuntu"}],"readingTime":11.425,"truncated":true,"authors":[{"name":"NotAShelf (raf)","title":"BrayanBot Developer & Lead Wiki Maintainer","url":"https://github.com/NotAShelf","image_url":"https://notashelf.dev/_next/image/?url=https%3A%2F%2Fmedia.discordapp.net%2Fattachments%2F815616931788357652%2F818941172591624192%2Fraf.jpg&w=256&q=75","imageURL":"https://notashelf.dev/_next/image/?url=https%3A%2F%2Fmedia.discordapp.net%2Fattachments%2F815616931788357652%2F818941172591624192%2Fraf.jpg&w=256&q=75"}],"frontMatter":{"title":"Hosting BrayanBot on a Raspberry Pi 400","description":"Got a spare Pi to run BrayanBot on? This is the place!","slug":"raspberry-pi-installation","authors":[{"name":"NotAShelf (raf)","title":"BrayanBot Developer & Lead Wiki Maintainer","url":"https://github.com/NotAShelf","image_url":"https://notashelf.dev/_next/image/?url=https%3A%2F%2Fmedia.discordapp.net%2Fattachments%2F815616931788357652%2F818941172591624192%2Fraf.jpg&w=256&q=75","imageURL":"https://notashelf.dev/_next/image/?url=https%3A%2F%2Fmedia.discordapp.net%2Fattachments%2F815616931788357652%2F818941172591624192%2Fraf.jpg&w=256&q=75"}],"tags":["Installation","Raspberry Pi","Linux","Ubuntu"],"image":"https://i.imgur.com/mErPwqL.png","hide_table_of_contents":false},"prevItem":{"title":"Hardening your Linux Server","permalink":"/blog/hardening-linux-server"}},"content":"import Tabs from \'@theme/Tabs\';\\nimport TabItem from \'@theme/TabItem\';\\n\\nWelcome to this blog! This page will provide instructions on how to install and run BrayanBot on a **Raspberry Pi 400** running Ubuntu 20.04. Interested? Great! Grab your popcorn, drinks, Raspberry Pi and click \\"Read More\\" to proceed.\\n\x3c!--truncate--\x3e\\n\\nFirst and foremost, happy Valentines Day everybody!\\nIf you are single, I will be your company *and* guide today. If not, I will only be your guide, but nevertheless; I am your guide today I hope to provide what you will need to host BrayanBot on a Raspberry Pi 400 running Ubuntu. Certainly not my favorite distribution but nevertheless, it somehow still holds the title of the most popular server distro.\\n> *If you would like to read my take on this matter, more about why you should not be using Ubuntu [here](/).*\\n\\nBut I digress, let us proceed with installation steps right away before I steal more of your time.\\n\\nAs you would expect, you will need a Raspberry Pi to connect to your server. Many people do not realise this, but Raspberry Pi is an awesome tech utility to have!\\nYou can run a website on it, or make a LEGO Tank with it. Or, as any sane person would do: you can use it to host BrayanBot, which we will do!\\n\\n## Installing Ubuntu on our Raspberry Pi\\n\\nMy Raspberry Pi 400 (like many others) came with its own Ubuntu spin, NOOBS operating system. It is a decent Ubuntu derivative that aims to introduce beginners to the basics of Linux but it also comes with Desktop Environment, which we do not need. That is exactly why we will be overwriting NOOBS with Ubuntu using this handy tool called [Raspberry Imager](https://www.raspberrypi.com/software/). It can be installed on Windows MacOS and Ubuntu from downloads page. Arch Linux users may install it from the AUR using `yay -S rpi-imager` or `yay -S rpi-imager-bin`. Install Imager and run it for the first time. It will look like this:<br/><br/>\\n![Imager](../assets/imager.png)<br/><br/>\\nWe will be choosing our operating system and storage medium, but before that I would like to talk about my personal recommendations.<br/><br/>\\n> Raspberry Pi 400 came with a 16GB SD card, which after around 2 weeks of use time; has proven itself to be insultingly low. If you are planning to use your Pi only to host BrayanBot, 16GB is perfectly enough; but if you have other awesome projects in mind, you might want to consider a 32 or 64 GB card.\\n\\nRegardless of your choice, choose your Operating System under the **Choose OS** tab.\\nFor this guide, we will be going with Ubuntu 20.04 Server (64 Bit) as our operating system but depending on your preferences, you may want to go with a different version of Ubuntu or an entirely different Operating System. For those sick of Ubuntu  Arch Linux is an excellent alternative, however, Manjaro may be a temporary stepping stone as installing Arch linux on a Raspberry Pi is relatively difficulty for a newbie.<br/>\\n\\n![Ubuntu 20.04](../assets/os-2.png)\\n\\nOnce you choose your Operating System, proceed to choosing your storage medium. I have used an 32 GB SD card in this installation but you may go as low as 16GB (any lesser might cause you problems) for this project. There are no upper limits to storage, you might as well buy a 1TB SD Card and use your Raspberry Pi as a desktop computer. Go wild!\\n\\n![Settings](../assets/os-3.png)\\n\\nNext up, is the most important step; configuring your SSH & Network connections.\\n\\n![SSH & Network Configuration](../assets/os-4.png)\\n\\nThings to note here:\\n\\n**Set hostname Setting**\\n\\n> Hostname is what you will use to connect to your Raspberry. Set it to anything you would like, it can be changed later from `/etc/hostname`\\n\\n**Enable SSH Setting**\\n\\n> This will basically allow SSH connections to your Pi. It is important that this setting is enabled, unless you plan on plugging in a monitor and configuring it later.\\n\\n**Set username and password Setting**\\n\\n> This will create your user with sudo permissions and desired password. In this example, **raf** is my username and it is what I will log in to the server with.\\n\\n**Configure Wifi Setting**\\n> Second most important setting is your Wifi. You may be planning to use your Pi connected to the internet with a cable, but if your Raspberry also has a single ethernet port like mine; you will want to use that port for a cable between your PC and Raspberry, so you can SSH locally. In this example **SSID** is the name of my Wifi network.\\n\\n**Set locale settings**\\n\\n> While not too important, its easier to configure them on this screen rather than after connecting to your raspberry. Choose your country and keyboard layout. As my Raspberry Pi comes with an US keyboard, I went with the default, US, but you may choose to use something different if your keyboard layout is different or if you have connected your own keyboard to your Pi.\\n\\nOnce all important setings are configured, hit save and then press the **Write** button to start burning the image on your SD card. This may take a little while. Why not grab a cup of coffee while we wait?\\n\\n## SSHing into the Server\\n\\nWe have successfully installed Ubuntu on our Raspberry Pi and it is ready to go! Insert your SD card to your Raspberry Pi and plug it to a power source. My Raspberry Pi came with a desktop kit, which included a power cord and an adaptor but if you do not have it; any USB 3.0 power cable will do the trick.\\n\\nStart by connecting the ethernet cable from your computer to your Raspberry Pi. This will allow you to connect from your device to the Pi **without** defining a static IP to your Pi and using SSH.\\n\\nI already have a SSH configuration on my device and I normally use it to connect easily, but as we are intalling a fresh server onto our Raspberry Pi; you will need to set up SSH for the first time. To do that, you need to SSH into the server! How to do that, you ask? Well that\'s simple, we have already configured our credentials for SSH and we can use those credentials to SSH into our Pi easily. Lets open the command line (or if you are on Windows, a terminal emulator like [Ki[Putty](/) or Powershell) and SSH into the server using our username and password.\\n\\n**Using Terminal**\\n```bash\\nssh raf@raspberry.local\\n```\\n\\nThis will prompt you to enter your password, which you have set during the installation. Enter your password, put on your hoodie and whisper:\\n*\\"I\'m in\\"*\\nBecause that was the hard part! We have successfully made it into the server.\\n\\n**Using Putty**<br/>\\n![Settings](../assets/putty.png)\\n<br/>\\n\\nHit open and connect to the server. You may -most probably will- see a warning about fingerprints. Hit yes, this will add your Raspberry Pi\'s fingerprint to your computer\'s trusted hosts and will not show up again. After that, you will be connected to your server. Unfortunately if you have used Putty, you do not get to put on a hoodie and whisper *\\"I\'m in\\"* but it is a perfect time to consider switching to Linux as your operating system! No pressure.\\n\\n## Installing NodeJS\\n\\nFirst and most importantly, update your packages.\\n```bash\\nsudo apt update && sudo apt upgrade\\n```\\nThen, you would normally run something like `sudo apt install nodejs npm` but NO! Since Ubuntu is a distro known for [leaving their packages outdated](/) the NodeJS from `apt install` is not the one we need. There are many third party repositories, one of which you may choose to install NodeJS but as the \\"third party\\" in the name indicates; they are not *always* trustable and thus, we will install it the *right way*.\\n\\nThe Raspberry Pi runs off the ARM architecture and as of the writing of this article, NodeJS releases compiled Linux binaries for ARMv6, ARMv7 and ARMv8 architectures, all of which you may find on their website\\n\\nTo find out which architecture your Raspberry Pi is running on, run the following command in the terminal\\n\\n`uname -m`\\n\\nFor example, if we run the above command on the Raspberry Pi 400, we get the following output. \\n\\n`armv7l`\\n\\n*Below, you will find a list of system architechtures for common Pi models but it is always a safe bet to check with `uname -m` as it may differ between devices despite sharing the same model number*\\n\\n  |        Board Name         |       Architechture     |\\n  | :-----------------------: | :---------------------: |\\n  | Raspberry Pi 400 \\t        |          ARMv7          |\\n  | Raspberry Pi 3 /3B+ \\t    |          ARMv7\\t\\t\\t\\t\\t|\\n  | Raspberry Pi 2B v1.2 \\t    |          ARMv7\\t\\t\\t\\t\\t|\\n  | Raspberry Pi 2B \\t        |          ARMv6\\t\\t\\t\\t\\t|\\n  | Raspberry Pi Zero /Zero W | \\t       ARMv6\\t\\t\\t\\t\\t|\\n\\nWe will now download the appropriate NodeJS release from NodeJS downloads page. To host BrayanBot, we will need [NodeJS V16](https://nodejs.org/dist/v16.14.0/) or [NodeJS V17](https://nodejs.org/dist/v17.5.0/)\\n\\nOnce you determine the apporpriate version, for example `node-v14.19.0-linux-armv7l.tar.gz` for a Raspberry Pi with ARMv7 archtechture version, install the relevant package with `wget node-vXX.XX.X-linux-armvXl.tar.gz` (replace X with your node version and architechture) abd extract the file you have downloaded with `tar -xzf node-vXX.XX.X-linux-armvXl.tar.gz`. After downloading, move into the tar you have extracted with `cd node-vXX.XX.X-linux-armvXl` and copy the contents to PATH using `sudo cp -R * /usr/local/`\\n\\nBefore you proceed, check if your installation was successful by running `node -v` and `npm -v` If it is, proceed to the next step. If not, join our [Discord Server](/discord) and ask for help.\\n\\nFinally, we are ready to download and install BrayanBot\\n\\n## Installing BrayanBot\\n\\n### Install Dependencies\\n\\n<Tabs>\\n<TabItem value=\\"debian\\" label=\\"Debian/Ubuntu\\">\\n\\n```bash\\nsudo apt install zip unzip wget \\n```\\n\\n</TabItem>\\n<TabItem value=\\"arch\\" label=\\"Arch\\">\\n\\n```bash\\nsudo pacman -S zip unzip wget\\n```\\n\\n</TabItem>\\n<TabItem value=\\"fedora\\" label=\\"RedHat/CentOS/Fedora\\">\\n\\n```bash\\nsudo dnf install zip unzip wget\\n```\\n\\n</TabItem>\\n</Tabs>\\n\\n### Download and Install BrayanBot\\n\\n<Tabs>\\n<TabItem value=\\"stable\\" label=\\"Stable\\">\\n\\n1. Download the zip file and unzip\\n```bash\\nwget https://github.com/brayanbotdev/brayanbot/releases/download/latest/brayanbot.zip &\\nunzip brayanbot.zip\\n```\\n1. Move into the BrayanBot Directory\\n```bash\\ncd BrayanBot\\n```\\n3. Copy the example config to the main `config.yml` \\n```bash\\ncp example.config.yml config.yml # cp is a built-in Linux command for copying files\\n```\\n**or if you would like to simply rename the file**\\n```bash\\nmv example.config.yml config.yml # mv is a built-in Linux command for moving files\\n```\\n4. Edit your `config.yml`\\n```bash\\nnano config.yml\\n```\\n**or**\\n```bash\\nvim config.yml # Imagine using vim\\n```\\n</TabItem>\\n<TabItem value=\\"Dev\\" label=\\"Dev\\">\\n\\n:::danger Dev Branch\\nIf you are interested in receiving updates *as soon as they are out* for the cost of high chance of breaking changes and less stability; you may clone into the **dev** branch instead of **main**. Changes from the dev branch will be *eventually* merged into main, but it is an option for those who like to live on edge.\\nYou also must keep in mind that using `git` will set up version control for your bot files and will make it harder to update if you have edited default -and tracked- bot files. **Do not** use this branch if you do not know how to use **git**.\\n:::\\n\\n1. Clone the Github Repo\\n```bash\\ngit clone -b dev https://github.com/BrayanBotDev/BrayanBot.git\\n```\\n2. Move into the BrayanBot Directory\\n```bash\\ncd BrayanBot\\n```\\n3. Copy the example config to the main `config.yml` \\n```bash\\ncp example.config.yml config.yml \\n```\\n**or if you would like to rename the file instead of copying**\\n```bash\\nmv example.config.yml config.yml\\n```\\n4. Edit your `config.yml`\\n```bash\\nnano config.yml\\n```\\n**or**\\n```bash\\nvim config.yml\\n```\\n</TabItem>\\n</Tabs>\\n\\n### Installing NodeJS Dependencies & Starting BrayanBot\\n\\n<Tabs>\\n<TabItem value=\\"yarn\\" label=\\"Yarn\\">\\n\\n1. Install Yarn\\n```bash\\nsudo npm i -g yarn\\n```\\n2. Install Required dependencies\\n```bash\\nyarn\\n```\\n3. Start the Bot\\n```bash\\nyarn start\\n```\\n\\n</TabItem>\\n<TabItem value=\\"npm\\" label=\\"NPM\\">\\n\\n1. Install Required dependencies\\n```bash\\nnpm install\\n```\\n2. Start the Bot\\n```bash\\nnpm run start\\n```\\n\\n</TabItem>\\n</Tabs>\\n\\n## Power Controls\\n\\nIf you would like to keep the bot running after you log out of your terminal/machine; you may use **PM2**. It will also allow you to have BrayanBot persist between reboots, if you configure it that way.\\n\\n### Using PM2 Process Manager\\n\\n```bash\\n# Install PM2 through NPM\\nsudo npm install -g pm2\\n# Start BrayanBot with PM2\\npm2 start index.js --name brayanbot\\n```\\n\\n- `pm2 stop brayanbot` # Stops the pm2 process\\n- `pm2 restart brayanbot` # Restart the process\\n- `pm2 logs brayanbot` # View recent logs as well as a live console\\n- `pm2 logs brayanbot --lines 1000 | nc termbin.com 9999` # Export the bot\'s past logs and paste them to termbin.\\n\\n## Final Thoughts\\n\\n>And that\'s it, that is all you need to do to start hosting BrayanBot without additional hosting costs. Of course, leaving a Raspberry Pi running 24/7 is not the most reliable way of running a service, BUT, using a Raspberry Pi creates an excellent sandbox for you get into using Linux and understanding the basics of running/securing a server without additional costs or risks. Once you feel comfortable with using this new server on your Raspberry Pi, you should consider taking a look at my [Securing your Linux Server](/blog/hardening-linux-server) guide. As some of our users have decided to purchase VPSes to run BrayanBot, we felt obligated to provide necessary instructions on securing your server. If you find this guide helpful, I\'m glad! If you think it was the most unhelpful guide you have ever read, please let me know, so I can improve it. And if you just want to talk Linux, that\'s fine too! Join our [Support Server](/discord) where we can talk freely.\\n\\nWith that said, I really do hope this guide was useful, thank you for your time."}]}')}}]);